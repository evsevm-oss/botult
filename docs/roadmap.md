## Roadmap: Телеграм-бот подсчета калорий по фото с AI-диетологом

> Важное: каноническая визуализация персонажа закреплена в `character/character_bot.png` и используется во всех документах/макетах/медиа.

Цель: создать бота, который помогает пользователю достигать целей по весу/жиру за счет подсчета калорий и макронутриентов, включая ввод по фото, и персональных рекомендаций AI-диетолога. На этом этапе исключаем продовый деплой и авто‑тесты, но допускаем ручные проверки на выделенном VPS (Debian 12, OVHcloud).

### Стратегические цели
- [ ] Надежный ввод рациона: текст и фото-распознавание (через GPT, без базы продуктов)
- [ ] Точные расчеты TDEE/BMR, дневных бюджетов и БЖУ под цели веса/жира
- [ ] Персональные рекомендации от AI-диетолога в контексте профиля и истории
- [ ] Прогресс: ежедневные/недельные сводки, графики веса/калорий/БЖУ
- [ ] Конфиденциальность и контроль данных пользователя
- [ ] Встроенные Telegram Web Apps для сложных интерфейсов (формы, дневник, графики)
- [ ] Контент: тексты, изображения, видео; персонализированные рассылки и сценарии взаимодействия

### Границы этапа
- [ ] В эту дорожную карту не входят: авто-тесты, CI/CD, продовый деплой

---

## Этап 0. Подготовка проекта
- [x] Сформулировать целевую аудиторию и ключевые сценарии (похудение, набор, поддержание) — см. `docs/audience-and-scenarios.mdc`
- [x] Уточнить ограничения и риски (стоимость LLM/vision, качество распознавания по фото) — см. `docs/risks-and-constraints.mdc`
- [x] Выбрать стек: Python 3.11+, Telegram Bot API (aiogram), FastAPI (внутренние сервисы), PostgreSQL, SQLAlchemy, Alembic, Redis (сессии/кэш), объектное хранилище для изображений (локально/минIO/S3), очередь задач (Celery/RQ) — см. `docs/stack.mdc`
- [x] Выбрать провайдеры AI: мультимодели (GPT-4o/Claude 3.5 Vision/Gemini 1.5); не использовать внешние пищевые базы (оценка нутриентов через GPT) — см. `docs/ai-providers.mdc`
- [x] Создать репозиторий и базовую структуру каталогов (бот, домен, сервисы, инфраструктура, миграции, данные)
- [x] Подготовить `.env.example` и схему конфигурации (секреты ключей Telegram/LLM/БД)
- [x] Описать глоссарий терминов (TDEE, BMR, БЖУ, прием пищи, порция, дневник) — см. `docs/glossary.mdc`
- [x] Разработать брендинг: логотип для аватарки Telegram (палитра, светлая/темная версии), экспорт ассетов (SVG/PNG 640×640/512×512/200×200) и размещение в `data/brand/` — см. `docs/brand-guide.mdc`


## Этап 1. Архитектура системы
- [x] Спроектировать компоненты: бот-обработчики, доменный слой, сервисы интеграций, слой данных — см. `docs/architecture.mdc`
- [x] Диаграмма потоков: пользователь → бот → доменные кейсы → БД/кэш → AI/vision → нормализация (через GPT, без пищевых баз) → ответ — см. `docs/architecture.mdc`
- [x] Определить границы модулей и зависимости (чистая архитектура/портно-адаптерный подход) — см. `docs/architecture.mdc`
- [x] Определить форматы контрактов: DTO/события/ошибки — см. `docs/contracts.mdc`
- [x] Архитектура Telegram Web Apps: фронтенд (React/Vite/Next), верификация `initData`, авторизация и обмен токенами, обмен данными (REST/WebSocket) — см. `docs/webapps-architecture.mdc`

## Этап 2. Модель данных и хранилища
- [x] ER-таблицы (минимум MVP): `users`, `profiles`, `weights`, `meals`, `meal_items`, `images`, `vision_inferences`, `llm_inferences`, `daily_summaries` — см. `infra/db/models.py`
- [x] Миграции стартовой схемы: `alembic/versions/0001_init_schema.py`
- [x] Аудит запросов AI: `llm_inferences` и `vision_inferences`; в `meal_items` хранится снимок нутриентов и единиц на момент ввода

## Этап 3. Базовые доменные расчеты
- [x] Реализовать формулы BMR (Mifflin–St Jeor, Katch–McArdle при наличии % жира) — см. `domain/calculations.py`
- [x] TDEE по уровню активности, дефицит/профицит под цель (темп изменения веса) — см. `domain/calculations.py`
- [x] Конвертация цели по % жира в целевой вес (оценка без/с учетом LBM) — см. `domain/calculations.py`
- [x] Распределение БЖУ (по умолчанию: белок г/кг LBM, жир %, углеводы остаток) — см. `domain/calculations.py`
- [x] Пересчет дневных бюджетов при изменениях профиля/веса/целей — `domain/use_cases/recalculate_daily_budgets.py`, REST `POST /api/recalculate`

## Этап 4. Каркас Telegram-бота
- [x] Подключение к Telegram Bot API, поллинг для локального запуска — см. `bot/main.py`
- [x] Базовые команды: `/start`, `/help`, `/profile`, `/addmeal`, `/photo`, `/coach`, `/stats`, `/settings` — см. `bot/routers/*`
- [x] Стейт‑машина диалогов (заготовка для `/addmeal`), middlewares (логирование, trace‑id, locale=RU) — см. `bot/middlewares/*`
- [x] Локализация (RU как дефолт) — текущие тексты RU, i18n добавим позже
- [x] Встроенные Web Apps: кнопка `web_app` при наличии `WEBAPP_URL` — см. `bot/keyboards.py`
- [x] Проверка `initData` WebApp на сервере — `POST /api/webapp/verify`


## Этап 5. Онбординг и профиль
- [x] Сбор: пол, возраст, рост, вес, уровень активности, цель (снижение/набор/поддержание)
- [x] Сохранение профиля, первичный расчет бюджетов (калории и БЖУ)
- [x] Экран/сообщение подтверждения профиля и бюджетов
 - [x] REST: GET/POST `/api/profile`
 - [x] WebApp: каркас страницы профиля (форма/просмотр) — `webapp/`

## Этап 6. Цели и дневные бюджеты
- [x] CRUD целей (изменение темпа, целевого веса/% жира) — REST `/api/goals`
- [x] Планирование недельного дефицита/профицита и дневных лимитов — (основа) пересчет дневных бюджетов при изменении профиля/веса (`/api/profile`, `/api/weights`)
- [x] Автообновление бюджетов при изменении веса/активности — POST `/api/weights` триггерит пересчет на дату

## Этап 7. Нормализация блюд и нутриентные оценки через GPT
- [x] Дизайн промптов и few-shot примеров для извлечения блюд, порций и нутриентов — (MVP) эвристический парсер `domain/use_cases/normalize_text.py`
- [x] Единый JSON-формат ответа: название, категория, масса/объем, калории, БЖУ, степень уверенности, допущения — `NormalizeResponse`
- [x] Нормализация единиц и порций (граммы/мл/штуки), калибровка типовых размеров — базовые правила (г/мл/шт)
- [x] Обработка неопределенности: запрос уточнений у пользователя, варианты выбора — флаг `needs_clarification`; добавлена опциональная интеграция OpenAI
- [x] Кэширование результатов и частых блюд — Redis‑кэш на 12 ч (`normalize:*`)

## Этап 8. Дневник питания
- [x] Прием сообщений в чате как есть (без специальных команд)
  - [x] Текст: нормализация через `/api/normalize`, превью и подтверждение (кнопки «Сохранить/Отменить/Править») — реализовано в FSM `/addmeal`
  - [x] Фото: принять фото — заглушка: создаем черновик, обещаем распознавание позже (бот `basic_router.on_photo`)
  - [x] Аудио/голос: STT (Whisper/OpenAI) → нормализация → подтверждение — реализовано
  - [x] Автоопределение типа приёма (завтрак/обед/ужин/перекус) по времени — серверная эвристика
  - [x] Черновики: статус `draft → confirmed`, «Отмена» — базовая реализация
  - [x] Идемпотентность по `update_id/message_id` — поля в модели и уникальные ключи; базовые заглушки в боте/сервере
- [x] REST дневника: CRUD
  - [x] GET `/api/meals?date=YYYY-MM-DD` (без параметра TZ пока)
  - [x] GET `/api/meals/{id}`
  - [x] POST `/api/meals` (создание приёма с `items`)
  - [x] PATCH `/api/meals/{id}`
  - [x] DELETE `/api/meals/{id}`
  - [x] Контракты/коды ошибок задокументированы в `docs/contracts.mdc`
- [ ] Бизнес‑логика
  - [x] Транзакционное обновление `daily_summary` при CRUD — реализовано
  - [x] Строгая проверка значений (масса, единицы, БЖУ), единообразные округления; дружественные сообщения об ошибках (частично через схемы)
- [x] Производительность и кэш
  - [x] Повторное использование Redis‑кэша нормализации для одинаковых сообщений; ключ = locale+text; метрики hit/miss
- [x] Логи и метрики
  - [x] Сквозной trace_id; метрики: доля авто‑подтверждений (через confirmed), среднее число позиций (items_total), время нормализации
- [x] WebApp (дневник)
  - [x] Список приёмов за день, просмотр позиций, удаление (простое)
  - [x] Редактирование (тип/заметка) и быстрое добавление, фильтр по датам

## Этап 9. Фото-логирование приемов пищи
- [ ] Прием фото/альбомов, привязка к приему и времени; мульти‑фото (медиагруппа) → один приём
- [ ] Предобработка: ресайз/компрессия/ориентация/EXIF; безопасный контент‑фильтр
- [ ] Пайплайн: очередь (Celery/RQ), статусы `queued → processing → ready → failed`; уведомления о готовности
- [x] Хранилище: S3/MinIO, sha256‑дедуп, превью/thumbnail — минимальная инициализация: локальный ObjectStorage, sha256 ключи
- [ ] Vision + GPT нормализация, разбиение сложных блюд; пороги уверенности и интерактивные уточнения
- [ ] Оценка порций по эвристикам (посуда/«ладонь/кулак»/стандартные размеры), ручная корректировка
- [ ] Диалог подтверждения: список блюд → выбор/корректировка → сохранение; фолбэк на ручной ввод
- [ ] Перформанс/стоимость: кэширование vision/LLM, лимиты размера/вызовов, учет стоимости на пользователя/день

## Этап 10. AI-диетолог (персональные рекомендации)
- [ ] Персона бота (визуал/тон); референс `character/character_bot.png`
- [ ] Контекст: профиль, цели, последние N дней, дефицит/профицит, частые блюда
- [ ] Инструменты: «предложить рацион», «замены под бюджет», «оценить приём», «список покупок» (инлайн‑кнопки для внесения изменений)
- [ ] Безопасность/стоимость: guardrails, лимиты токенов/частоты, учёт стоимости на пользователя
- [ ] Генерация контента: персонализированные шаблоны, сценарии коротких видео (скрипт→саб→озвучка)
- [ ] UX: CTA и интерактив (внести/заменить/сохранить) в один клик

## Этап 11. Прогресс и отчеты
- [ ] Ежедневные/недельные/месячные сводки; тренды веса/калорий/БЖУ; комплаенс к целям
- [ ] Прогноз веса при текущем темпе; выявление выбросов/пропусков
- [ ] Кэш агрегатов; корректные TZ/границы дня; экспорт CSV
- [ ] WebApp: графики/сводки; напоминания о взвешиваниях/приемах; форматы контента (карусели/дайджесты)

## Этап 12. Настройки и персонализация
- [ ] Единицы измерения (кг/фунты, мл/унции), часовой пояс/TZ, локаль
- [ ] Предпочтения/аллергии/диет‑режим; предупреждения при подтверждении приёмов — инициализировано: `/api/settings` (перенесено из Этапа 8)
- [ ] Частота уведомлений; времена приемов пищи
- [ ] Избранные блюда/рецепты, пользовательские блюда (композиции)
- [ ] Экспорт/импорт/удаление данных пользователя (privacy)
- [ ] Настройки рассылок: частота, часы, типы контента, opt‑in/out на видео

## Этап 13. Качество данных и наблюдаемость (без тестов)
- [ ] Структурированное логирование с trace_id; OpenTelemetry/Prometheus; Sentry для ошибок
- [ ] Метрики LLM: латентность, cost, success rate; алерты по очередям/ошибкам
- [ ] Аудит изменений дневника и профиля (кто/когда/что)
- [ ] Регулярная очистка устаревших медиа/временных артефактов
- [ ] Метрики контента: open rate, CTR, досматриваемость видео, отписки

## Этап 14. Производительность и стоимость
- [ ] Rate limiting (LLM/vision); фоновые задачи; backpressure
- [ ] Кэширование ответов LLM/vision (с дедупликацией); TTL кэшей; дедуп тяжёлых запросов
- [ ] Ограничение размеров изображений и количества вызовов к провайдеру
- [ ] Перенос тяжелых задач (распознавание/нормализация) в очередь, ленивые ответы в чат
- [ ] Транскодирование видео (FFmpeg), ограничение длительности/размера, прогрессивная отправка; хранение в объектном хранилище/кэш

## Этап 15. Документация разработчика
- [ ] README: запуск локально, структура каталогов, переменные окружения; Dev/Ops runbooks
- [ ] Полный OpenAPI (FastAPI), примеры запросов/ответов; контракты в `docs/contracts.mdc`
- [ ] Диаграммы: архитектура, ERD, основные последовательности (onboarding, добавление еды, фото‑логирование)
- [ ] Примеры сообщений/шаблонов и команд бота

## Этап 16. Готовность к продукту (без деплоя/тестов)
- [ ] Полный сценарий «первый день»: онбординг → расчет бюджетов → добавление еды (вручную/по фото) → сводка дня → советы AI
- [ ] QA‑чеклист сценариев; локализация RU/EN; доступность (a11y)
- [ ] Проверка UX‑углов: пустые состояния, отмены, ошибки провайдеров, долгие операции (индикация ожидания)
- [ ] Справка/FAQ в боте, дисклеймер по медицинским ограничениям

## Этап 17. Контент: сообщения, видео и рассылки
- [ ] Контентная матрица: онбординг, обучение, рецепты, мотивация, отчеты, промо
- [ ] Библиотека шаблонов: текст/изображение/видео; переменные персонализации, i18n; A/B‑тестирование
- [ ] Создание видео: пайплайн «скрипт → раскадровка/изображения → субтитры → озвучка → рендер → отправка»
- [ ] Структура отправки: сегментация, планировщик, rate limits, приоритеты, отложенные/повторные сообщения, отмена
- [ ] Каналы доставки: личные сообщения (текст/медиа/видео/медиагруппы), Web App страницы/ссылки
- [ ] Согласия и соответствие: Telegram антиспам, opt‑in/out, управление отписками
- [ ] Хранилище контента и аналитика эффективности; единый стиль бренда в UI/сообщениях

## Этап 18. Брендинг: дизайн-система
- [ ] Внедрить дизайн-систему для Web App: палитра, типографика, компоненты, иконки, радиусы и отступы
- [ ] Обновить шаблоны сообщений и клавиатуры бота под стиль бренда
- [ ] Подготовить гайдлайны по бренду (структура ассетов, нейминг, превью) и обновлять их по мере изменений

---

### Пользовательские истории (минимальный набор)
- [ ] Как пользователь, я могу пройти онбординг и получить персональные калории/БЖУ
- [ ] Как пользователь, я могу внести прием пищи вручную, указать блюда/ингредиенты и порции
- [ ] Как пользователь, я могу отправить фото блюда и подтвердить распознанный состав
- [ ] Как пользователь, я вижу прогресс дня и рекомендации, чтобы уложиться в бюджет
- [ ] Как пользователь, я могу спросить у AI-диетолога, как улучшить мой рацион
- [ ] Как пользователь, я могу открыть Web App внутри Telegram для удобного ввода и просмотра аналитики
- [ ] Как пользователь, я могу получать персональные текстовые сообщения и короткие видео с рекомендациями

### Критерий «полноценного работающего продукта» (без тестов/деплоя)
- [ ] Стабильные основные сценарии: онбординг → расчет бюджетов → ввод пищи (текст/фото) → сводки/отчеты → AI-подсказки
- [ ] Данные корректно сохраняются, редактируются и экспортируются
- [ ] Расчеты калорий и БЖУ соответствуют выбранным формулам и целям
- [ ] При ошибках провайдеров предусмотрены фолбэки и понятные сообщения
- [ ] Рассылка контента работает: тексты/медиа/видео с персонализацией и учётом настроек пользователя (частота/формат)


